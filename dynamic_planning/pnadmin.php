<?php
// $Id$
// ----------------------------------------------------------------------
// Dynamic Planning Module
// Copyright (C) 2002 by Curtis Nelson.
// http://www.liminis.com/~curtis/
// ----------------------------------------------------------------------
// LICENSE
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License (GPL)
// as published by the Free Software Foundation; either version 2
// of the License, or (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WIthOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// To read the license please visit http://www.gnu.org/copyleft/gpl.html
// ----------------------------------------------------------------------
// Original Author of file: Jim McDonald
// Current  Author of file: Curtis Nelson
// Purpose of file:  Dynamic Planning administration display functions
// ----------------------------------------------------------------------

/**
 * the main administration function
 * This function is the default function, and is called whenever the
 * module is initiated without defining arguments.  As such it can
 * be used for a number of things, but most commonly it either just
 * shows the module menu and returns or calls whatever the module
 * designer feels should be the default function (often this is the
 * view() function)
 */
function dynamic_planning_admin_main()
{
    // Create output object - this object will store all of our output so that
    $output = new pnHTML();

    // Security check - important to do this as early as possible to avoid
    if (!pnSecAuthAction(0, 'dynamic_planning::', '::', ACCESS_EDIT)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Add menu to output - it helps if all of the module pages have a standard
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->Text(dynamic_planning_adminmenu());
    $output->SetInputMode(_PNH_PARSEINPUT);

    // Return the output that has been generated by this function
    return $output->GetOutput();
}

/**
 * add new track
 * This is a standard function that is called whenever an administrator
 * wishes to create a new track
 */
function dynamic_planning_admin_new()
{
    // Create output object 
    $output = new pnHTML();

    // Security check 
    if (!pnSecAuthAction(0, 'dynamic_planning::', '::', ACCESS_ADMIN)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Add menu to output
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->Text(dynamic_planning_adminmenu());
    $output->SetInputMode(_PNH_PARSEINPUT);

    // Title
    $output->Title(_ADDDP);

    // Start form 
    $output->FormStart(pnModURL('dynamic_planning', 'admin', 'create'));

    // Add an authorisation ID 
    $output->FormHidden('authid', pnSecGenAuthKey());

    // Start the table 
    $output->TableStart();

    // Name
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPNAME));
    $row[] = $output->FormText('trackname', '', 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);
    
    //Track Leader
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPLEAD));
    $row[] = $output->FormText('tracklead', '', 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);
				    
    // Text
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPTEXT));
    $row[] = $output->FormText('tracktext', '', 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    $output->TableEnd();

    // End form
    $output->Linebreak(2);
    $output->FormSubmit(_DPADD);
    $output->FormEnd();

    // Return the output that has been generated by this function
    return $output->GetOutput();
}

/**
 * This is a standard function that is called with the results of the
 * form supplied by dynamic_planning_admin_new() to create a new item
 * @param 'name' the name of the item to be created
 * @param 'number' the number of the item to be created
 */
function dynamic_planning_admin_create($args)
{
    // Get parameters from whatever input we need.  All arguments to this
    list($trackname,
         $tracktext) = pnVarCleanFromInput('trackname',
                                           'tracktext');

    // Admin functions of this type can be called by other modules.  If this
    extract($args);

    // Confirm authorisation code.  This checks that the form had a valid
    if (!pnSecConfirmAuthKey()) {
        pnSessionSetVar('errormsg', _BADAUTHKEY);
        pnRedirect(pnModURL('dynamic_planning', 'admin', 'new'));
        return true;
    }

    if (!pnModAPILoad('dynamic_planning', 'admin')) {
        pnSessionSetVar('errormsg', _LOADFAILED);
        return $output->GetOutput();
    }

    // The API function is called.  Note that the name of the API function and
    $trackid = pnModAPIFunc('dynamic_planning',
                        'admin',
                        'create',
                        array('trackname' => $trackname,
                              'tracktext' => $tracktext));

    // The return value of the function is checked here, and if the function
    if ($trackid != false) {
        // Success
        pnSessionSetVar('statusmsg', _DPCREATED);
    }

    // This function generated no output, and so now it is complete we redirect
    pnRedirect(pnModURL('dynamic_planning', 'user', 'view'));

    // Return
    return true;
}

/**
 * modify a track
 * This is a standard function that is called whenever an administrator
 * wishes to modify a current module item
 * @param 'trackid' the id of the track to be modified
 */
function dynamic_planning_admin_modify($args)
{
    // Get parameters from whatever input we need.  All arguments to this
    list($trackid,
         $objectid)= pnVarCleanFromInput('trackid',
                                         'objectid');

    // Admin functions of this type can be called by other modules.  If this
    extract($args);

    // At this stage we check to see if we have been passed $objectid, the
    if (!empty($objectid)) {
        $trackid = $objectid;
    }                       

    // Create output object - this object will store all of our output so that
    $output = new pnHTML();

    // Load API.  Note that this is loading the user API, that is because the
    if (!pnModAPILoad('dynamic_planning', 'user')) {
        $output->Text(_LOADFAILED);
        return $output->GetOutput();
    }

    // The user API function is called.  This takes the item ID which we
    $track = pnModAPIFunc('dynamic_planning',
                         'user',
                         'gettrack',
                         array('trackid' => $trackid));

    if ($track == false) {
        $output->Text(_DPNOSUCHITEM);
        return $output->GetOutput();
    }

    // Security check - important to do this as early as possible to avoid
    if (!pnSecAuthAction(0, 'dynamic_planning::', "$track[trackname]::", ACCESS_EDIT)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Add menu to output - it helps if all of the module pages have a standard
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->Text(dynamic_planning_adminmenu());
    $output->SetInputMode(_PNH_PARSEINPUT);

    // Title - putting a title ad the head of each page reminds the user what
    $output->Title(_EDITDP);

    // Start form - note the use of pnModURL() to create the recipient URL of
    $output->FormStart(pnModURL('dynamic_planning', 'admin', 'update'));

    // Add an authorisation ID - this adds a hidden field in the form that
    $output->FormHidden('authid', pnSecGenAuthKey());

    // Add a hidden variable for the item id.  This needs to be passed on to
    $output->FormHidden('trackid', pnVarPrepForDisplay($trackid));

    // Start the table that holds the information to be input.  Note how each
    $output->TableStart();

    // Name
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPNAME));
    $row[] = $output->FormText('trackname', pnVarPrepForDisplay($track['trackname']), 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Number
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPNUMBER));
    $row[] = $output->FormText('tracktext', pnVarPrepForDisplay($track['tracktext']), 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    $output->TableEnd();

    // End form
    $output->Linebreak(2);
    $output->FormSubmit(_DPUPDATE);
    $output->FormEnd();
    
    // Return the output that has been generated by this function
    return $output->GetOutput();
}

/**
 * modify a task
 * This is a standard function that is called whenever an administrator
 * wishes to modify a current module item
 * @param 'trackid' the id of the track to be modified
 */
function dynamic_planning_admin_modifytask($args)
{
    // Get parameters from whatever input we need.  All arguments to this
    list($taskid,
         $objectid)= pnVarCleanFromInput('taskid',
                                         'objectid');

    // Admin functions of this type can be called by other modules.  If this
    extract($args);

    // At this stage we check to see if we have been passed $objectid, the
    if (!empty($objectid)) {
        $taskid = $objectid;
    }

    // Create output object - this object will store all of our output so that
    $output = new pnHTML();

    // Load API.  Note that this is loading the user API, that is because the
    if (!pnModAPILoad('dynamic_planning', 'user')) {
        $output->Text(_LOADFAILED);
        return $output->GetOutput();
    }

    // The user API function is called.  This takes the item ID which we
    $task = pnModAPIFunc('dynamic_planning',
                         'user',
                         'gettask',
                         array('taskid' => $taskid));

    if ($task == false) {
        $output->Text(_DPNOSUCHITEM);
        return $output->GetOutput();
    }

    // Security check - important to do this as early as possible to avoid
    if (!pnSecAuthAction(0, 'dynamic_planning::', "$track[trackname]::", ACCESS_EDIT)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Add menu to output - it helps if all of the module pages have a standard
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->Text(dynamic_planning_adminmenu());
    $output->SetInputMode(_PNH_PARSEINPUT);

    // Title - putting a title ad the head of each page reminds the user what
    $output->Title(_EDITDP);

    // Start form - note the use of pnModURL() to create the recipient URL of
    $output->FormStart(pnModURL('dynamic_planning', 'admin', 'updatetask'));

    // Add an authorisation ID - this adds a hidden field in the form that
    $output->FormHidden('authid', pnSecGenAuthKey());

    // Add a hidden variable for the item id.  This needs to be passed on to
    $output->FormHidden('taskid', pnVarPrepForDisplay($taskid));
    $output->FormHidden('trackid', pnVarPrepForDisplay($task['trackid']));
    // Start the table that holds the information to be input.  Note how each
    $output->TableStart();

    // Title
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPTITLE));
    $row[] = $output->FormText('tasktitle', pnVarPrepForDisplay($task['tasktitle']), 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Description
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPDESC));
    $row[] = $output->FormText('tasktext', pnVarPrepForDisplay($task['tasktext']), 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Start
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPSTART));
    $row[] = $output->FormText('taskstart', pnVarPrepForDisplay($task['taskstart']), 12, 12);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // End
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPEND));
    $row[] = $output->FormText('taskend', pnVarPrepForDisplay($task['taskend']), 12, 12);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Percent Complete
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPPERC));
    $row[] = $output->FormText('taskpercent', pnVarPrepForDisplay($task['taskpercent']), 5, 5);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Steps
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPSTEPS));
    $row[] = $output->FormText('tasksteps', pnVarPrepForDisplay($task['tasksteps']), 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Team
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPTEAM));
    $row[] = $output->FormText('taskteam', pnVarPrepForDisplay($task['taskteam']), 32, 32);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);


    $output->TableEnd();

    // End form
    $output->Linebreak(2);
    $output->FormSubmit(_DPUPDATE);
    $output->FormEnd();

    // Return the output that has been generated by this function
    return $output->GetOutput();
}


/**
 * This is a standard function that is called with the results of the
 * form supplied by dynamic_planning_admin_modify() to update a current item
 * @param 'trackd' the id of the item to be updated
 * @param 'trackname' the name of the item to be updated
 * @param 'tracktext' the number of the item to be updated
 */
function dynamic_planning_admin_update($args)
{
    // Get parameters from whatever input we need.  All arguments to this
    extract($args);

    list($trackid,
         $objectid,
         $trackname,
         $tracktext) = pnVarCleanFromInput('trackid',
                                        'objectid',
                                        'trackname',
                                        'tracktext');

    // User functions of this type can be called by other modules.  If this
    extract($args);
                            
    // At this stage we check to see if we have been passed $objectid, the
    if (!empty($objectid)) {
        $trackid = $objectid;
    }                       

    // Confirm authorisation code.  This checks that the form had a valid
    if (!pnSecConfirmAuthKey()) {
        pnSessionSetVar('errormsg', _BADAUTHKEY);
        pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));
        return true;
    }

    // Load API.  All of the actual work for the update of the new item is done
    if (!pnModAPILoad('dynamic_planning', 'admin')) {
        pnSessionSetVar('errormsg', _LOADFAILED);
        return $output->GetOutput();
    }

    // The API function is called.  Note that the name of the API function and
    if(pnModAPIFunc('dynamic_planning',
                    'admin',
                    'update',
                    array('trackid' => $trackid,
                          'trackname' => $trackname,
                          'tracktext' => $tracktext))) {
        // Success
        pnSessionSetVar('statusmsg', _DPUPDATED);
    }

    // This function generated no output, and so now it is complete we redirect
    pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));

    // Return
    return true;
}

/**
 * This is a standard function that is called with the results of the
 * form supplied by dynamic_planning_admin_modify() to update a current item
 * @param 'tid' the id of the item to be updated
 * @param 'name' the name of the item to be updated
 * @param 'number' the number of the item to be updated
 */
function dynamic_planning_admin_updatetask($args)
{
    // Get parameters from whatever input we need.  All arguments to this
    extract($args);

    list($taskid,
         $trackid,
         $objectid,
         $tasktitle,
         $tasktext,
	 $taskstart,
	 $taskend,
	 $taskpercent,
	 $tasksteps,
	 $taskteam) = pnVarCleanFromInput('taskid',
	                                'trackid',
                                        'objectid',
                                        'tasktitle',
                                        'tasktext',
					'taskstart',
					'taskend',
					'taskpercent',
					'tasksteps',
					'taskteam');

    // User functions of this type can be called by other modules.  If this
    extract($args);

    // At this stage we check to see if we have been passed $objectid, the
    if (!empty($objectid)) {
        $taskid = $objectid;
    }

    // Confirm authorisation code.  This checks that the form had a valid
    if (!pnSecConfirmAuthKey()) {
        pnSessionSetVar('errormsg', _BADAUTHKEY);
        pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));
        return true;
    }

    // Load API.  All of the actual work for the update of the new item is done
    if (!pnModAPILoad('dynamic_planning', 'admin')) {
        pnSessionSetVar('errormsg', _LOADFAILED);
        return $output->GetOutput();
    }

    // The API function is called.  Note that the name of the API function and
    if(pnModAPIFunc('dynamic_planning',
                    'admin',
                    'updatetask',
                    array('taskid' => $taskid,
                          'tasktitle' => $tasktitle,
                          'tasktext' => $tasktext,
			  'taskstart' => $taskstart,
			  'taskend' => $taskend,
			  'taskpercent' => $taskpercent,
			  'tasksteps' => $tasksteps,
			  'taskteam' => $taskteam))) {
        // Success
        pnSessionSetVar('statusmsg', _DPUPDATED);
    }

    // This function generated no output, and so now it is complete we redirect
    pnRedirect(pnModURL('dynamic_planning', 'user', 'display', array ('trackid' => $trackid)));

    // Return
    return true;
}

/**
 * delete item
 * This is a standard function that is called whenever an administrator
 * wishes to delete a current module item.  Note that this function is
 * @param 'tid' the id of the item to be deleted
 * @param 'confirmation' confirmation that this item can be deleted
 */
function dynamic_planning_admin_delete($args)
{
    // Get parameters from whatever input we need.  All arguments to this
    // function should be obtained from pnVarCleanFromInput(), getting them
    // from other places such as the environment is not allowed, as that makes
    // assumptions that will not hold in future versions of PostNuke
    list($trackid,
         $objectid,
         $confirmation) = pnVarCleanFromInput('trackid',
                                              'objectid',
                                              'confirmation');


    // User functions of this type can be called by other modules.  If this
    // happens then the calling module will be able to pass in arguments to
    // this function through the $args parameter.  Hence we extract these
    // arguments *after* we have obtained any form-based input through
    // pnVarCleanFromInput().
    extract($args);

    $output = new pnHTML();

     // At this stage we check to see if we have been passed $objectid, the
     // generic item identifier.  This could have been passed in by a hook or
     // through some other function calling this as part of a larger module, but
     // if it exists it overrides $tid
     //
     // Note that this module couuld just use $objectid everywhere to avoid all
     // of this munging of variables, but then the resultant code is less
     // descriptive, especially where multiple objects are being used.  The
     // decision of which of these ways to go is up to the module developer
     if (!empty($objectid)) {
         $trackid = $objectid;
     }                     

    // Load API.  Note that this is loading the user API, that is because the
    // user API contains the function to obtain item information which is the
    // first thing that we need to do.  If the API fails to load an appropriate
    // error message is posted and the function returns
    if (!pnModAPILoad('dynamic_planning', 'user')) {
        $output->Text(_LOADFAILED);
        return $output->GetOutput();
    }

    // The user API function is called.  This takes the item ID which we
    // obtained from the input and gets us the information on the appropriate
    // item.  If the item does not exist we post an appropriate message and
    // return
    $item = pnModAPIFunc('dynamic_planning',
                         'user',
                         'getall'
                         );

    if ($item == false) {
        $output->Text(_DPNOSUCHITEM);
        return $output->GetOutput();
    }

    // Security check - important to do this as early as possible to avoid
    // potential security holes or just too much wasted processing.  However,
    // in this case we had to wait until we could obtain the item name to
    // complete the instance information so this is the first chance we get to
    // do the check
    if (!pnSecAuthAction(0, 'dynamic_planning::Item', "::", ACCESS_DELETE)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Check for confirmation. 
    if (empty($confirmation)) {
        // No confirmation yet - display a suitable form to obtain confirmation
        // of this action from the user

        // Create output object - this object will store all of our output so
        // that we can return it easily when required
//        $output = new pnHTML();

        // Add menu to output - it helps if all of the module pages have a
        // standard menu at their head to aid in navigation
        $output->SetInputMode(_PNH_VERBATIMINPUT);
        $output->Text(dynamic_planning_adminmenu());
        $output->SetInputMode(_PNH_PARSEINPUT);

        // Title - putting a title ad the head of each page reminds the user
        // what they are doing
        $output->Title(_DELETEDP);

        // Add confirmation to output.  Note that this uses a pnHTML helper
        // function to produce the requested confirmation in a standard
        // fashion.  This not only cuts down on code within the module but
        // allows it to be altered in future without the module developer
        // having to worry about it
        $output->ConfirmAction(_CONFIRMDPDELETE,
                               pnModURL('dynamic_planning',
                                        'admin',
                                        'delete'),
                               _CANCELDPDELETE,
                               pnModURL('dynamic_planning',
                                        'admin',
                                        'view'),
                               array('trackid' => $trackid));

        // Return the output that has been generated by this function
        return $output->GetOutput();
    }

    // If we get here it means that the user has confirmed the action

    // Confirm authorisation code.  This checks that the form had a valid
    // authorisation code attached to it.  If it did not then the function will
    // proceed no further as it is possible that this is an attempt at sending
    // in false data to the system
    if (!pnSecConfirmAuthKey()) {
        pnSessionSetVar('errormsg', _BADAUTHKEY);
        pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));
        return true;
    }

    // Load API.  All of the actual work for the deletion of the item is done
    // within the API, so we need to load that in before before we can do
    // anything.  If the API fails to load an appropriate error message is
    // posted and the function returns
    if (!pnModAPILoad('dynamic_planning', 'admin')) {
        $output->Text(_LOADFAILED);
        return $output->GetOutput();
    }

    // The API function is called.  Note that the name of the API function and
    // the name of this function are identical, this helps a lot when
    // programming more complex modules.  The arguments to the function are
    // passed in as their own arguments array.
    //
    // The return value of the function is checked here, and if the function
    // suceeded then an appropriate message is posted.  Note that if the
    // function did not succeed then the API function should have already
    // posted a failure message so no action is required
    if (pnModAPIFunc('dynamic_planning',
                     'admin',
                     'delete',
                     array('trackid' => $trackid))) {
        // Success
        pnSessionSetVar('statusmsg', _DPDELETED);
    }

    // This function generated no output, and so now it is complete we redirect
    // the user to an appropriate page for them to carry on their work
    pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));
    
    // Return
    return true;
}

/**
 * view items
 */
function dynamic_planning_admin_view()
{
    // Create output object - this object will store all of our output so that
    $output = new pnHTML();

    if (!pnSecAuthAction(0, 'dynamic_planning::', '::', ACCESS_EDIT)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Add menu to output - it helps if all of the module pages have a standard
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->Text(dynamic_planning_adminmenu());
    $output->SetInputMode(_PNH_PARSEINPUT);

    // Title - putting a title ad the head of each page reminds the user what
    // they are doing
    $output->Title(_VIEWDP);

    // Load API.  Note that this is loading the user API, that is because the
    // user API contains the function to obtain item information which is the
    // first thing that we need to do.  If the API fails to load an appropriate
    // error message is posted and the function returns
    if (!pnModAPILoad('dynamic_planning', 'user')) {
        $output->Text(_LOADFAILED);
        return $output->GetOutput();
    }

    // The user API function is called.  This takes the number of items
    // required and the first number in the list of all items, which we
    // obtained from the input and gets us the information on the appropriate
    // items.
    $items = pnModAPIFunc('dynamic_planning',
                          'user',
                          'getall');

    // Start output table
    $output->TableStart('',
                        array(_DPNAME,
                              _DPNUMBER,
                              _DPOPTIONS),
                        3);

    foreach ($items as $item) {

        $row = array();

    
            // Name and number.  Note that unlike the user function we do not
            // censor the text that is being displayed.  This is so the
            // administrator can see the text as exists in the database rather
            // than the munged output version
            $output->SetOutputMode(_PNH_RETURNOUTPUT);
            $row[] = $output->URL(pnModURL('dynamic_planning',
                                  'user',
                                  'display',
                                  array('trackid' => $item['trackid'])),
                         pnVarPrepForDisplay($item['trackname']));
            $row[] = $item['tracktext'];

            // Options for the item.  Note that each item has the appropriate
            // levels of authentication checked to ensure that it is suitable
            // for display

            $options = array();
            $output->SetOutputMode(_PNH_RETURNOUTPUT);
            if (pnSecAuthAction(0, 'dynamic_planning::', "::$item[trackid]", ACCESS_EDIT)) {
                $options[] = $output->URL(pnModURL('dynamic_planning',
                                                   'admin',
                                                   'modify',
                                                   array('trackid' => $item['trackid'])),
                                          _EDIT);
                if (pnSecAuthAction(0, 'dynamic_planning::', "::$item[trackid]", ACCESS_DELETE)) {
                    $options[] = $output->URL(pnModURL('dynamic_planning',
                                                       'admin',
                                                       'delete',
                                                       array('trackid' => $item['trackid'])),
                                              _DELETE);
                }
            }

            $options = join(' | ', $options);
            $output->SetInputMode(_PNH_VERBATIMINPUT);
            $row[] = $output->Text($options);
            $output->SetOutputMode(_PNH_KEEPOUTPUT);
            $output->TableAddRow($row);
            $output->SetInputMode(_PNH_PARSEINPUT);
        }
    
    $output->TableEnd();

    // Call the pnHTML helper function to produce a pager in case of there
    // being many items to display.
    //
    // Note that this function includes another user API function.  The
    // function returns a simple count of the total number of items in the item
    // table so that the pager function can do its job properly

    // Return the output that has been generated by this function
    return $output->GetOutput();
}


/**
 * This is a standard function to modify the configuration parameters of the
 * module
 */
function dynamic_planning_admin_modifyconfig()
{
    // Create output object - this object will store all of our output so that
    // we can return it easily when required
    $output = new pnHTML();

    // Security check - important to do this as early as possible to avoid
    // potential security holes or just too much wasted processing

    if (!pnSecAuthAction(0, 'dynamic_planning::', '::', ACCESS_ADMIN)) {
        $output->Text(_DPNOAUTH);
        return $output->GetOutput();
    }

    // Add menu to output - it helps if all of the module pages have a standard
    // menu at their head to aid in navigation
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->Text(dynamic_planning_adminmenu());
    $output->SetInputMode(_PNH_PARSEINPUT);

    // Title - putting a title ad the head of each page reminds the user what
    // they are doing
    $output->Title(_DPMODIFYCONFIG);

    // Start form - note the use of pnModURL() to create the recipient URL of
    // this form.  All URLs should be generated through pnModURL() to ensure
    // compatibility with future versions of PostNuke
    $output->FormStart(pnModURL('dynamic_planning', 'admin', 'updateconfig'));


    // Add an authorisation ID - this adds a hidden field in the form that
    // contains an authorisation ID.  The authorisation ID is very important in
    // preventing certain attacks on the website
    $output->FormHidden('authid', pnSecGenAuthKey());

    // Start the table that holds the information to be modified.  Note how
    // each item in the form is kept logically separate in the code; this helps
    // to see which part of the code is responsible for the display of each
    // item, and helps with future modifications
    $output->TableStart();

    // Bold
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPDISPLAYBOLD));
    $row[] = $output->FormCheckbox('bold', pnModGetVar('dynamic_planning', 'bold'));
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    // Number of items to display per page
    $row = array();
    $output->SetOutputMode(_PNH_RETURNOUTPUT);
    $row[] = $output->Text(pnVarPrepForDisplay(_DPITEMSPERPAGE));
    $row[] = $output->FormText('itemsperpage', pnModGetVar('dynamic_planning', 'itemsperpage'), 3, 3);
    $output->SetOutputMode(_PNH_KEEPOUTPUT);
    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddrow($row, 'left');
    $output->SetInputMode(_PNH_PARSEINPUT);
    $output->Linebreak(2);

    $output->TableEnd();

    // End form
    $output->Linebreak(2);
    $output->FormSubmit(_DPUPDATE);
    $output->FormEnd();
    
    // Return the output that has been generated by this function
    return $output->GetOutput();
}

/**
 * This is a standard function to update the configuration parameters of the
 * module given the information passed back by the modification form
 */
function dynamic_planning_admin_updateconfig()
{
    // Get parameters from whatever input we need.  All arguments to this
    // function should be obtained from pnVarCleanFromInput(), getting them
    // from other places such as the environment is not allowed, as that makes
    // assumptions that will not hold in future versions of PostNuke
    $bold = pnVarCleanFromInput('bold');

    // Confirm authorisation code.  This checks that the form had a valid
    // authorisation code attached to it.  If it did not then the function will
    // proceed no further as it is possible that this is an attempt at sending
    // in false data to the system
    if (!pnSecConfirmAuthKey()) {
        pnSessionSetVar('errormsg', _BADAUTHKEY);
        pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));
        return true;
    }

    // Update module variables.  Note that depending on the HTML structure used
    // to obtain the information from the user it is possible that the values
    // might be unset, so it is important to check them all and assign them
    // default values if required
    if (!isset($bold)) {
        $bold = 0;
    }
    pnModSetVar('dynamic_planning', 'bold', $bold);

    if (!isset($itemsperpage)) {
        $itemsperpage = 10;
    }
    pnModSetVar('dynamic_planning', 'itemsperpage', $itemsperpage);

    // This function generated no output, and so now it is complete we redirect
    // the user to an appropriate page for them to carry on their work
    pnRedirect(pnModURL('dynamic_planning', 'admin', 'view'));

    // Return
    return true;
}
/**
 * Main administration menu
 */
function dynamic_planning_adminmenu()
{
    // Create output object - this object will store all of our output so that
    // we can return it easily when required
    $output = new pnHTML();

    // Display status message if any.  Note that in future this functionality
    // will probably be in the theme rather than in this menu, but this is the
    // best place to keep it for now
    $output->Text(pnGetStatusMsg());
    $output->Linebreak(2);

    // Start options menu
    $output->TableStart(_DP);
    $output->SetOutputMode(_PNH_RETURNOUTPUT);

    // Menu options.  These options are all added in a single row, to add
    // multiple rows of options the code below would just be repeated
    $columns = array();
    $columns[] = $output->URL(pnModURL('dynamic_planning',
                                        'admin',
                                        'new'),
                              _NEWDP); 
    $columns[] = $output->URL(pnModURL('dynamic_planning',
                                        'admin',
                                        'view'),
                              _VIEWDP); 
    $columns[] = $output->URL(pnModURL('dynamic_planning',
                                        'admin',
                                        'modifyconfig'),
                              _EDITDPCONFIG); 
    $output->SetOutputMode(_PNH_KEEPOUTPUT);

    $output->SetInputMode(_PNH_VERBATIMINPUT);
    $output->TableAddRow($columns);
    $output->SetInputMode(_PNH_PARSEINPUT);

    $output->TableEnd();

    // Return the output that has been generated by this function
    return $output->GetOutput();
}

?>
